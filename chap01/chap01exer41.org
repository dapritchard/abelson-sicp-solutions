#+TITLE: SICP Exercise 1.41

#+OPTIONS: date:nil
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+OPTIONS: html-style:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="github-pandoc.css" />
#+STARTUP: showeverything
#+PROPERTY: :tangle yes

#+LaTeX_HEADER: \usepackage[margin=1in]{geometry}
#+LaTeX_HEADER: \usepackage[x11names]{xcolor}
#+LaTeX_HEADER: \usepackage{amsthm}
#+LaTeX_HEADER: \usepackage{titlesec}
#+LaTeX_HEADER: \usepackage{xpatch}
#+LaTeX_HEADER: \usepackage{realboxes}
#+LaTeX_HEADER: \hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue4, citecolor = PaleGreen1, linkcolor = black}

#+BEGIN_EXPORT latex
  % remove excess whitespace after \maketitle command
  \vspace{-20mm}
#+END_EXPORT

#+BEGIN_EXPORT latex
% background color for code environments
\definecolor{lightyellow}{RGB}{255,255,224}
\definecolor{lightbrown}{RGB}{249,234,197}
\definecolor{codeblockgray}{RGB}{230,230,230}

\lstset{%
  basicstyle=\fontsize{9.75}{10.75}\fontfamily{pcr}\selectfont
}

% create a listings environment for Bash
\lstdefinestyle{scheme}{%
  language=lisp,
  % backgroundcolor=\color{lightyellow},
  backgroundcolor=\color{gray!15},
  basicstyle=\fontsize{9.75}{10.75}\fontfamily{pcr}\selectfont,
  keywordstyle=\color{Firebrick3},
  stringstyle=\color{Green4},
  commentstyle=\color{Purple3},
  showstringspaces=false,
  morecomment=[l]{userid@},
  morecomment=[l]{onyenid@},
  morecomment=[l]{localid@},
  morecomment=[l]{sftp> },
  moredelim=[is][\bfseries]{[*@}{@*]},
  frame=single,
  frameround={tttt},
  rulecolor=\color{gray!50}% ,
  % framexleftmargin=2pt,
  % framextopmargin=2pt,
  % framexrightmargin=2pt,
  % framexbottommargin=2pt
}

% titlesec documentation:
% http://ctan.mackichan.com/macros/latex/contrib/titlesec/titlesec.pdf

% see pgs 4-5 of documentation for titlespacing syntax.  The command signature
% is: \titlespacing*{<command>}{<left>}{<before-sep>}{<after-sep>}[<right-sep>]
\titlespacing*{\section}{0pt}{10mm plus 1ex minus .2ex}{2mm plus .2ex}
\titlespacing*{\subsection}{0pt}{10mm plus 1ex minus .2ex}{2mm plus .2ex}
\titlespacing*{\subsubsection}{0pt}{5mm plus 1ex minus .2ex}{2mm plus .2ex}

% \pretitle{\begin{center}\LARGE}
% \posttitle{\par\end{center}\vskip 0.5em}
% \preauthor{\begin{center}
% \large \lineskip 0.5em%
% \begin{tabular}[t]{c}}
% \postauthor{\end{tabular}\par\end{center}}
% \predate{\begin{center}\large}
% \postdate{\par\end{center}}

\makeatletter
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\LARGE \@title \par}%
    Hello, world
    \vskip 1.5em%
    {\large
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author
      \end{tabular}\par}%
    \vskip 1em%
    {\large \@date}%
  \end{center}%
  \par
  \vskip 1.5em}
\fi
\makeatother

% see the following links for this definition:
%
%     https://tex.stackexchange.com/a/357339/88779
%     https://tex.stackexchange.com/q/408878
\makeatletter
\xpretocmd\lstinline
{%
  \bgroup\fboxsep=1.5pt
  \Colorbox{gray!15}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
  \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
}{}{}
\makeatother


% use the `scheme` listings definition
\lstset{style=scheme}
#+END_EXPORT




* Exercise 1.41

Define a procedure src_lisp[:exports code]{double} that takes a procedure of
one argument as an argument and returns a procedure that applies the original
procedure twice.  For example, if src_lisp[:exports code]{inc} is a procedure
that adds 1 to its argument, then src_lisp[:exports code]{(double inc)} should
be a procedure that adds 2.  What value is returned by the following expression?

#+BEGIN_SRC lisp
  (((double (double double)) inc) 5)
#+END_SRC




* Solution
:PROPERTIES:
:CUSTOM_ID: solution
:END:

** Definition of =double=
:PROPERTIES:
:CUSTOM_ID: double-definition
:END:

We define the function src_lisp[:exports code]{double} as follows.
#+BEGIN_SRC lisp
  ;; takes an input function `f` and returns a function that takes an input and
  ;; applies `f` to it twice
  (define (double f)
    (lambda (x)
      (f (f x))))
#+END_SRC



** Example usage
:PROPERTIES:
:CUSTOM_ID: example-usage
:END:

A few examples using src_lisp[:exports code]{double} are shown below.  We can see from the pattern that
having $n$ instances of src_lisp[:exports code]{double} causes there to be $2^{2^{n-1}}$ calls to
src_lisp[:exports code]{inc}.
#+BEGIN_SRC lisp
  ;; define `inc`
  (define (inc x) (1+ x))

  ;; evaluates to the values 1, 2, 4, 16, 256, 65536
  (inc 0)
  ((double inc) 0)
  (((double double) inc) 0)
  (((double (double double)) inc) 0)
  (((double (double (double double))) inc) 0)
  (((double (double (double (double double)))) inc) 0)

  ;; evaluates to the value 21
  (((double (double double)) inc) 5)
#+END_SRC




** Tracing through the function call
:PROPERTIES:
:CUSTOM_ID: function-trace
:END:

The following figure is provided to illustrate why the expression
src_lisp[:exports code]{(((double (double double)) inc) 5)} results in 16
calls to src_lisp[:exports code]{inc}.  There are a few conventions that are
used in the figure in an attempt to make things more clear.  Rectangles are
placed around some constructs to indicate that they are a function when taken as
a whole.  Additionally, functions that are used either as arguments or as lambda
expression constructs are sometimes indicated by using a $\bullet$ (representing
arguments) rather than as a valid Scheme expression so as to reduce visual
clutter and sidestep syntactic details.
# So for example, rather than writing
# src_lisp[:exports code]{(lambda (x) (inc (inc x)))}, we might write
# src_lisp[:exports code]{(inc (inc } $\bullet$ src_lisp[:exports code]{))}.

We start with the original expression in Step 1, and in Step 2 we evaluate the
expression src_lisp[:exports code]{(double double)} (using our $\bullet$
notation), creating a new function that we denote by surrounding it with a
rectangle.  Then in Step 3 we evaluate the outermost call to src_lisp[:exports
code]{double}, creating a new function that is composed of the two functions
denoted by the inner rectangular boxes.

Next, in Step 4 we begin to thread the input argument src_lisp[:exports
code]{inc} into our newly created function.  While the ordering depends on the
implementation of the interpreter, at some point the src_lisp[:exports
code]{inc} argument will make its way all the way to the innermost call to
src_lisp[:exports code]{double}, which is the step that is shown here as the
innermost rectangle in the right-hand term.

Next, in Step 5 the newly created function is passed to the next call to
src_lisp[:exports code]{double}.  Then in Step 6 we can pass this entire
function to the next call to src_lisp[:exports code]{double} creating yet
another function, which can then be passed to the outermost call to
src_lisp[:exports code]{double} in Step 7.

#+BEGIN_EXPORT latex
\begin{figure}[htb]
  \caption{A visual trace of the function call from Exercise 1.41.}
  \vspace{3mm}
  \includegraphics[width=1\textwidth]{figures/chap01exer41-callgraph.pdf}
\end{figure}
#+END_EXPORT

#+BEGIN_EXPORT html
  <style>
  .aligncenter {
      text-align: center;
  }
  </style>

  <p class="aligncenter">
    <img src="figures/chap01exer41-callgraph.svg" align="middle" />
  </p>
#+END_EXPORT




** Discussion of the results
:PROPERTIES:
:CUSTOM_ID: discussion-of-results
:END:

To see why having $n$ instances of src_lisp[:exports code]{double} causes
there to be $2^{2^{n-1}}$ calls to src_lisp[:exports code]{inc}, we again
refer to [[#function-trace]] as an illustration.  Firstly, in Steps 1-3 we see
that $2^{n-1}$ calls to src_lisp[:exports code]{double} are created.  Then in
Steps 4-7 we see that each call to src_lisp[:exports code]{double} generates
twice as many calls to the input function as in the previous step, resulting in
the expression $2^{2^{n-1}}$.
